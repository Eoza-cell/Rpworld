import {
  default as makeWASocket,
  DisconnectReason,
  useMultiFileAuthState
} from '@whiskeysockets/baileys';
import qrcode from 'qrcode-terminal';
import dotenv from 'dotenv';

import database from './src/database.js';
import playerManager from './src/player.js';
import worldManager from './src/world.js';
import actionDetector from './src/actionDetector.js';
import consequences from './src/consequences.js';
import npcManager from './src/npcs.js';
import pollinations from './src/pollinations.js';
import webServer from './src/webServer.js';
import economy from './src/economy.js';

dotenv.config();

class EspritMondeBot {
  constructor() {
    this.sock = null;
    this.isReady = false;
  }

  async init() {
    console.log('üåê Initialisation ESPRIT-MONDE...');

    webServer.init();
    webServer.updateStatus('Initialisation de la base de donn√©es...', false);

    await database.init();
    console.log('‚úÖ Base de donn√©es initialis√©e');
    webServer.updateStatus('Initialisation du monde...', false);

    await worldManager.init();
    console.log('‚úÖ Monde ESPRIT-MONDE initialis√©');
    webServer.updateStatus('Connexion √† WhatsApp...', false);

    await this.connectToWhatsApp();
  }

  async connectToWhatsApp() {
    try {
      const { state, saveCreds } = await useMultiFileAuthState('auth_info_baileys');

      const connectionMethod = process.env.CONNECTION_METHOD || 'pairing';
      const phoneNumber = process.env.PHONE_NUMBER;

      this.sock = makeWASocket({
        auth: state,
        printQRInTerminal: false,
        browser: ['Ubuntu', 'Chrome', '128.0.6613.86'],
        version: [2, 3000, 1025190524],
        getMessage: async key => {
          console.log('‚ö†Ô∏è Message non d√©chiffr√©, retry demand√©:', key);
          return { conversation: 'üîÑ R√©essaye d\'envoyer ton message' };
        }
      });

      this.sock.ev.on('creds.update', saveCreds);

      this.sock.ev.on('connection.update', async (update) => {
        const { connection, lastDisconnect, qr } = update;

        if (qr) {
          if (connectionMethod === 'pairing' && phoneNumber && !this.sock.authState.creds.registered) {
            try {
              const code = await this.sock.requestPairingCode(phoneNumber);
              const formattedCode = code?.match(/.{1,4}/g)?.join('-') || code;
              
              console.log('\nüîë CODE DE JUMELAGE WHATSAPP');
              console.log('‚îÅ'.repeat(50));
              console.log(`üì± Code: ${formattedCode}`);
              console.log('üì≤ √âtapes:');
              console.log('   1. Ouvrez WhatsApp sur votre t√©l√©phone');
              console.log('   2. Allez dans Param√®tres > Appareils connect√©s');
              console.log('   3. Appuyez sur "Connecter un appareil"');
              console.log('   4. Entrez ce code: ' + formattedCode);
              console.log('‚îÅ'.repeat(50));
              console.log('‚è≥ En attente de la connexion...\n');

              webServer.updateStatus(`üîë Code de jumelage: ${formattedCode}`, false);
            } catch (error) {
              console.error('‚ùå Erreur lors de la g√©n√©ration du code de jumelage:', error);
              console.log('üîÑ Basculement vers le mode QR Code...');
              console.log('\nüì± Scannez ce QR Code avec WhatsApp:\n');
              qrcode.generate(qr, { small: true });
              console.log('\n‚è≥ En attente du scan...\n');

              webServer.updateQRCode(qr);
              webServer.updateStatus('‚è≥ En attente du scan QR Code', false);
            }
          } else if (connectionMethod === 'qr' || !phoneNumber) {
            console.log('\nüì± Scannez ce QR Code avec WhatsApp:\n');
            qrcode.generate(qr, { small: true });
            console.log('\n‚è≥ En attente du scan...\n');

            webServer.updateQRCode(qr);
            webServer.updateStatus('‚è≥ En attente du scan QR Code', false);
          }
        }

        if (connection === 'close') {
          const statusCode = lastDisconnect?.error?.output?.statusCode;
          const errorMessage = lastDisconnect?.error?.message || 'Erreur inconnue';

          console.log('‚ùå Connexion ferm√©e.');
          console.log('üìù Raison:', errorMessage);
          console.log('üìã Code:', statusCode);

          webServer.updateStatus(`‚ùå D√©connect√©: ${errorMessage}`, false);
          webServer.updateQRCode(null);

          const shouldReconnect = statusCode !== DisconnectReason.loggedOut;

          if (shouldReconnect) {
            console.log('üîÑ Reconnexion dans 3 secondes...');
            webServer.updateStatus('üîÑ Reconnexion en cours...', false);
            await new Promise(resolve => setTimeout(resolve, 3000));
            await this.connectToWhatsApp();
          } else {
            console.log('‚ö†Ô∏è D√©connect√©. Supprimez le dossier auth_info_baileys et relancez.');
            webServer.updateStatus('‚ö†Ô∏è D√©connect√© - Red√©marrage requis', false);
          }
        } else if (connection === 'open') {
          console.log('‚úÖ Bot connect√© √† WhatsApp !');
          console.log('üéÆ ESPRIT-MONDE est pr√™t √† jouer !');
          this.isReady = true;

          webServer.updateStatus('‚úÖ Connect√© - Bot actif', true);
          webServer.updateQRCode(null);
        }
      });

      this.sock.ev.on('messages.upsert', async ({ messages, type }) => {
        if (type === 'notify') {
          await this.handleMessage(messages);
        }
      });
    } catch (error) {
      console.error('üí• Erreur lors de la connexion:', error);
      console.log('üîÑ Nouvelle tentative dans 5 secondes...');
      await new Promise(resolve => setTimeout(resolve, 5000));
      await this.connectToWhatsApp();
    }
  }

  async handleMessage(messages) {
    for (const message of messages) {
      if (!message.message || message.key.fromMe) continue;

      const from = message.key.remoteJid;
      const text = message.message.conversation ||
                   message.message.extendedTextMessage?.text || '';
      const participant = message.key.participant; // Get participant for group messages

      if (!text) continue;

      const isGroup = from.endsWith('@g.us');

      if (isGroup && !text.startsWith('/')) { // Ignore messages in groups that are not commands
        continue;
      }

      console.log(`üì® Message de ${from}${participant ? ` (via ${participant})` : ''}: ${text}`);

      try {
        await this.processPlayerAction(from, text, isGroup, participant);

        const playerCount = Object.keys(database.players).length;
        webServer.updatePlayerCount(playerCount);
      } catch (error) {
        console.error('Erreur traitement message:', error);
        await this.sendMessage(from, "‚ùå Une erreur s\'est produite dans ESPRIT-MONDE...");
      }
    }
  }

  async processPlayerAction(from, text, isGroup, participant) {
    const phoneNumber = isGroup ? participant.replace('@s.whatsapp.net', '') : from.replace('@s.whatsapp.net', '');
    const pushName = text.split(' ')[0]; // This might not be the player's name, consider using message.pushName if available
    const player = await playerManager.getOrCreatePlayer(phoneNumber, pushName);

    if (text.toLowerCase() === '/start' || text.toLowerCase() === '/commencer') {
      await this.sendWelcomeMessage(from, player, isGroup);
      return;
    }

    if (text.toLowerCase() === '/stats') {
      const stats = playerManager.getStatsDisplay(player);
      const location = await worldManager.getLocationDescription(player.position.location);
      await this.sendMessage(from, `${stats}\n\n${location}`);
      return;
    }

    if (text.toLowerCase() === '/help' || text.toLowerCase() === '/aide') {
      await this.sendHelpMessage(from, isGroup);
      return;
    }

    if (text.toLowerCase() === '/metiers' || text.toLowerCase() === '/jobs') {
      await this.showJobs(from, player);
      return;
    }

    if (text.toLowerCase().startsWith('/postuler ')) {
      const jobId = text.split(' ')[1];
      await this.applyForJob(from, player, jobId);
      return;
    }

    if (text.toLowerCase() === '/permis' || text.toLowerCase() === '/licenses') {
      await this.showLicenses(from, player);
      return;
    }

    if (text.toLowerCase().startsWith('/acheter_permis ')) {
      const licenseType = text.split(' ')[1];
      await this.buyLicense(from, player, licenseType);
      return;
    }

    if (text.toLowerCase() === '/vehicules' || text.toLowerCase() === '/vehicles') {
      await this.showVehicles(from, player);
      return;
    }

    if (text.toLowerCase().startsWith('/acheter_vehicule ')) {
      const vehicleId = text.split(' ')[1];
      await this.buyVehicle(from, player, vehicleId);
      return;
    }

    if (text.toLowerCase() === '/banque' || text.toLowerCase() === '/bank') {
      await this.showBank(from, player);
      return;
    }

    if (text.toLowerCase().startsWith('/deposer ')) {
      const amount = parseInt(text.split(' ')[1]);
      await this.depositMoney(from, player, amount);
      return;
    }

    if (text.toLowerCase().startsWith('/retirer ')) {
      const amount = parseInt(text.split(' ')[1]);
      await this.withdrawMoney(from, player, amount);
      return;
    }

    if (!playerManager.isAlive(player)) {
      await this.sendMessage(from, "üíÄ Tu es mort. Tape /start pour recommencer une nouvelle vie.");
      return;
    }

    await this.handleFreeAction(from, player, text, isGroup);
  }

  async handleFreeAction(from, player, actionText, isGroup) {
    await this.sendMessage(from, "‚è≥ ESPRIT-MONDE analyse ton action...");

    const currentLocation = await worldManager.getLocation(player.position.location);
    const time = await worldManager.getCurrentTime();

    const actionAnalysis = await actionDetector.analyzeAction(actionText, {
      player,
      location: currentLocation,
      time
    });

    const calculatedConsequences = await consequences.calculate(
      actionAnalysis,
      player,
      currentLocation
    );

    playerManager.updateStats(player, calculatedConsequences.statChanges);

    if (calculatedConsequences.positionChange) {
      playerManager.updatePosition(player, calculatedConsequences.positionChange);
    }

    if (calculatedConsequences.inventoryChange) {
      if (calculatedConsequences.inventoryChange.money) {
        playerManager.addMoney(player, calculatedConsequences.inventoryChange.money);
      }
    }

    if (calculatedConsequences.wantedChange) {
      playerManager.updateStats(player, { wanted: calculatedConsequences.wantedChange });
    }

    const npcsPresent = await npcManager.getNPCsInLocation(player.position.location);
    const npcReactions = await npcManager.reactToPlayerAction(
      actionAnalysis,
      player,
      player.position.location
    );

    playerManager.addToHistory(player, actionText, calculatedConsequences);
    await database.savePlayer(from, player);

    const narrativeContext = {
      action: actionText,
      playerStats: player.stats,
      location: currentLocation?.name || player.position.location,
      time: `${time.hour}h, ${time.period}`,
      weather: time.weather,
      consequences: JSON.stringify(calculatedConsequences.statChanges),
      npcsPresent: npcsPresent.map(n => n.name).join(', ')
    };

    const narrative = await pollinations.generateNarrative(narrativeContext);

    let response = `üé≠ **ESPRIT-MONDE**\n\n${narrative}\n\n`;

    if (npcReactions.length > 0) {
      response += `üë• ${npcReactions.join(' ')}\n\n`;
    }

    response += playerManager.getStatsDisplay(player);

    if (calculatedConsequences.events.length > 0) {
      response += `\n\n‚ö° √âv√©nements: ${calculatedConsequences.events.join(', ')}`;
    }

    await this.sendMessage(from, response);

    if (!playerManager.isAlive(player)) {
      await this.sendMessage(from, "\n\nüíÄ **TU ES MORT**\nTa sant√© est tomb√©e √† z√©ro. Ton aventure se termine ici.\nTape /start pour recommencer.");
    }
  }

  async sendWelcomeMessage(chatId, player, isGroup = false) {
    const greeting = isGroup ? `üéÆ ${player.name}, bienvenue dans ESPRIT-MONDE !` : `üåç **ESPRIT-MONDE** üåç`;

    const welcome = `${greeting}

Tu es ${player.name}, voyageur du monde o√π chaque action a des cons√©quences r√©elles.

üéÆ **SYST√àME ESPRIT-MONDE**
Une IA contr√¥le tout: le temps, les PNJ, les √©v√©nements, et r√©agit √† tes actions libres.

üìä **Tes Stats**
${playerManager.getStatsDisplay(player)}

üìç **Ta Position**
${await worldManager.getLocationDescription(player.position.location)}

‚úçÔ∏è **Comment jouer**
√âcris simplement ce que tu veux faire en langage naturel:
- "Je vais √† Tokyo"
- "Je me prom√®ne dans les rues"
- "Je parle aux passants"
- "J'ach√®te de la nourriture"

‚å®Ô∏è **Commandes**
/stats - Voir tes statistiques
/help - Aide compl√®te

üåü Ton aventure commence maintenant. Que fais-tu ?`;

    await this.sendMessage(chatId, welcome);
  }

  async sendHelpMessage(chatId, isGroup = false) {
    const help = `üìö **GUIDE ESPRIT-MONDE**

**Actions Libres:**
√âcris ce que tu veux faire naturellement. L'IA comprend et r√©agit.

**Barres d'√âtat:**
‚ù§Ô∏è Sant√© - Si 0%, tu meurs
‚ö° √ânergie - Diminue avec l'action
üçî Faim - Mange pour survivre
üß† Mental - Affect√© par le stress
üö® Wanted - Niveau de recherche police

**Commandes Principales:**
/stats - Tes statistiques
/metiers - Voir les m√©tiers
/permis - Voir les permis
/vehicules - Voir les v√©hicules
/banque - Compte bancaire
/help - Cette aide

**√âconomie:**
/postuler [m√©tier] - Postuler √† un m√©tier
/acheter_permis [type] - Acheter un permis
/acheter_vehicule [type] - Acheter un v√©hicule
/deposer [montant] - D√©poser √† la banque
/retirer [montant] - Retirer de la banque

**Villes du Monde:**
üá´üá∑ Paris ‚Ä¢ üáØüáµ Tokyo ‚Ä¢ üá∫üá∏ New York ‚Ä¢ üá¶üá™ Dubai
üá¨üáß Londres ‚Ä¢ üáßüá∑ Rio ‚Ä¢ üá¶üá∫ Sydney ‚Ä¢ üáπüá∑ Istanbul
üá∑üá∫ Moscou ‚Ä¢ üáπüá≠ Bangkok ‚Ä¢ üá∫üá∏ Los Angeles ‚Ä¢ üá©üá™ Berlin
üá®üá¶ Montr√©al ‚Ä¢ üá≥üá± Amsterdam ‚Ä¢ üá∞üá∑ S√©oul`;

    await this.sendMessage(chatId, help);
  }

  async showJobs(chatId, player) {
    const jobs = economy.getJobsList();
    let message = 'üíº **M√âTIERS DISPONIBLES**\n\n';

    jobs.forEach(job => {
      const canApply = economy.canApplyForJob(player, job.id);
      message += `**${job.name}** ${job.illegal ? '‚ö†Ô∏è' : ''}\n`;
      message += `üí∞ Salaire: ${job.salary}$/mois\n`;
      message += `${canApply.can ? '‚úÖ Disponible' : '‚ùå ' + canApply.reason}\n`;
      message += `Commande: /postuler ${job.id}\n\n`;
    });

    await this.sendMessage(chatId, message);
  }

  async applyForJob(chatId, player, jobId) {
    const canApply = economy.canApplyForJob(player, jobId);

    if (!canApply.can) {
      await this.sendMessage(chatId, `‚ùå ${canApply.reason}`);
      return;
    }

    const job = economy.jobs[jobId];
    playerManager.setJob(player, job.name, job.salary);
    await database.savePlayer(player.phoneNumber, player);

    await this.sendMessage(chatId, `‚úÖ F√©licitations ! Tu es maintenant ${job.name}.\nüí∞ Salaire: ${job.salary}$/mois\n\nTravaille pour gagner de l'argent et de l'exp√©rience !`);
  }

  async showLicenses(chatId, player) {
    let message = 'üìú **PERMIS ET LICENCES**\n\n';

    message += `üöó Permis de Conduire: ${player.licenses.driving ? '‚úÖ Obtenu' : '‚ùå Non obtenu (500$)'}\n`;
    message += `üî´ Permis de Port d\'Arme: ${player.licenses.gun ? '‚úÖ Obtenu' : '‚ùå Non obtenu (1000$)'}\n`;
    message += `üè¢ Licence Commerciale: ${player.licenses.business ? '‚úÖ Obtenu' : '‚ùå Non obtenu (2000$)'}\n\n`;

    message += 'Pour acheter: /acheter_permis [driving/gun/business]';

    await this.sendMessage(chatId, message);
  }

  async buyLicense(chatId, player, licenseType) {
    const licenseInfo = economy.getLicenseInfo(licenseType);

    if (!licenseInfo) {
      await this.sendMessage(chatId, '‚ùå Permis inconnu');
      return;
    }

    if (player.licenses[licenseType]) {
      await this.sendMessage(chatId, '‚ùå Tu poss√®des d√©j√† ce permis');
      return;
    }

    const result = playerManager.grantLicense(player, licenseType, licenseInfo.cost);

    if (result.success) {
      await database.savePlayer(player.phoneNumber, result.player);
      await this.sendMessage(chatId, `‚úÖ ${licenseInfo.name} obtenu ! (-${licenseInfo.cost}$)`);
    } else {
      await this.sendMessage(chatId, `‚ùå Argent insuffisant (${licenseInfo.cost}$ requis)`);
    }
  }

  async showVehicles(chatId, player) {
    const vehicles = economy.getVehiclesList();
    let message = 'üöó **V√âHICULES DISPONIBLES**\n\n';

    vehicles.forEach(v => {
      message += `**${v.name}**\n`;
      message += `üí∞ Prix: ${v.price}$\n`;
      message += `‚ö° Vitesse: ${'‚ñ∞'.repeat(v.speed)}${'‚ñ±'.repeat(5-v.speed)}\n`;
      message += `${v.requiresLicense ? 'üöó Permis requis' : '‚úÖ Pas de permis'}\n`;
      message += `Commande: /acheter_vehicule ${v.id}\n\n`;
    });

    if (player.inventory.vehicles.length > 0) {
      message += '\n**TES V√âHICULES:**\n';
      player.inventory.vehicles.forEach(v => {
        message += `üöó ${v.name} - Carburant: ${v.fuel}%\n`;
      });
    }

    await this.sendMessage(chatId, message);
  }

  async buyVehicle(chatId, player, vehicleId) {
    const vehicleInfo = economy.getVehicleInfo(vehicleId);

    if (!vehicleInfo) {
      await this.sendMessage(chatId, '‚ùå V√©hicule inconnu');
      return;
    }

    const result = playerManager.buyVehicle(player, vehicleInfo);

    if (result.success) {
      await database.savePlayer(player.phoneNumber, result.player);
      await this.sendMessage(chatId, `‚úÖ ${vehicleInfo.name} achet√© ! Tu peux maintenant te d√©placer plus rapidement.`);
    } else if (result.reason === 'no_license') {
      await this.sendMessage(chatId, '‚ùå Permis de conduire requis ! Utilise /acheter_permis driving');
    } else {
      await this.sendMessage(chatId, `‚ùå Argent insuffisant (${vehicleInfo.price}$ requis)`);
    }
  }

  async showBank(chatId, player) {
    const message = `üè¶ **BANQUE INTERNATIONALE**\n\nüí∞ Argent liquide: ${player.inventory.money}$\nüè¶ Compte bancaire: ${player.inventory.bankAccount}$\nüíé Total: ${player.inventory.money + player.inventory.bankAccount}$\n\n/deposer [montant] - D√©poser\n/retirer [montant] - Retirer`;
    await this.sendMessage(chatId, message);
  }

  async depositMoney(chatId, player, amount) {
    const result = playerManager.depositMoney(player, amount);
    if (result.success) {
      await database.savePlayer(player.phoneNumber, result.player);
      await this.sendMessage(chatId, `‚úÖ ${amount}$ d√©pos√©s √† la banque`);
    } else {
      await this.sendMessage(chatId, '‚ùå Argent insuffisant');
    }
  }

  async withdrawMoney(chatId, player, amount) {
    const result = playerManager.withdrawMoney(player, amount);
    if (result.success) {
      await database.savePlayer(player.phoneNumber, result.player);
      await this.sendMessage(chatId, `‚úÖ ${amount}$ retir√©s de la banque`);
    } else {
      await this.sendMessage(chatId, '‚ùå Fonds insuffisants');
    }
  }

  async sendMessage(to, text) {
    try {
      await this.sock.sendMessage(to, { text });
    } catch (error) {
      console.error('Erreur envoi message:', error);
    }
  }
}

const bot = new EspritMondeBot();
bot.init().catch(console.error);